%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
% This file is part of ScholarLY,                                             %
%                      =========                                              %
% a toolkit library for scholarly work with GNU LilyPond and LaTeX,           %
% belonging to openLilyLib (https://github.com/openlilylib/openlilylib        %
%              -----------                                                    %
%                                                                             %
% ScholarLY is free software: you can redistribute it and/or modify           %
% it under the terms of the GNU General Public License as published by        %
% the Free Software Foundation, either version 3 of the License, or           %
% (at your option) any later version.                                         %
%                                                                             %
% ScholarLY is distributed in the hope that it will be useful,                %
% but WITHOUT ANY WARRANTY; without even the implied warranty of              %
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               %
% GNU Lesser General Public License for more details.                         %
%                                                                             %
% You should have received a copy of the GNU General Public License           %
% along with ScholarLY.  If not, see <http://www.gnu.org/licenses/>.          %
%                                                                             %
% ScholarLY is maintained by Urs Liska, ul@openlilylib.org                    %
% Copyright Urs Liska, 2015                                                   %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%{
  This file defines the actual engraver
%}

%%%%%%%%%%
% Helpers:
%
% Predicate: an annotation is an alist that at least contains a number of
% default keys (which should usually be generated by the \annotate music function)
#(define (input-annotation? obj)
   (and
    (list? obj)
    (every pair? obj)
    (assq-ref obj 'message)
    (assq-ref obj 'type)
    (assq-ref obj 'location)))

% Create custom property 'annotation
% to pass information from the music function to the engraver
#(set-object-property! 'input-annotation 'backend-type? input-annotation?)
#(set-object-property! 'input-annotation 'backend-doc "custom grob property")

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Helper functions for the annotationCollector engraver

% Produce highlighting for the anchor of an annotation
#(define (color-anchor grob ann-type)
   (if (getOption '(scholarly annotate use-colors))
       (ly:grob-set-property! grob 'color
         (getChildOption '(scholarly annotate colors) ann-type))))


%%%%%%%%%%%%%%%%%%%%%%%%
% Annotation engraver(s)
%
% annotationCollector and annotationProcessor work together,
% the Collector being \consist-ed on all necessary Staff-level contexts,
% the Processor being \consist-ed in the Score context.

% Collector acknowledges annotations and appends them
% to the global annotations object
annotationCollector =
#(let*
  ((annotated-grobs '())
   (all-grobs '()))
  (lambda (context)
    (make-engraver
     (acknowledgers
      ((grob-interface engraver grob source-engraver)
       ;; 'input-annotation property is only visible in process-acknowledged,
       ;; therefore we have to record *all* grobs here
       (set! all-grobs (cons grob all-grobs))))
     ((process-acknowledged translator)
      (for-each
       (lambda (grob)
         (let*
          ((annotation (ly:grob-property grob 'input-annotation))
           (ann-type (assq-ref annotation 'ann-type))
           (is-annotation
            ;; A grob is to be accepted when 'annotation *does* have some content
            ;; and is not marked as ignored.
            (and ann-type
                 (not (member ann-type
                        (getOption '(scholarly annotate ignored-types)))))))
          (if is-annotation
              (let*
               ((do-process
                 (or (getOption '(scholarly annotate print))
                     (not (null? (getOption '(scholarly annotate export-targets)))))))
               ;; Coloring is done regardless of annotation export
               (color-anchor grob ann-type)
               (if do-process
                   ;; Enrich the annotation with information that is only available now.
                   (let*
                    ((_context-id
                      ;; Set _context-id to
                      ;; a) an explicit 'context' attribute
                      ;; b) an implicit context name through the named Staff context or
                      ;; c) the directory.file as determined by \tagSpan
                      (or (assq-ref annotation 'context)
                          (let ((actual-context-id (ly:context-id context)))
                            (if (not (member actual-context-id (list "" "\\new")))
                                actual-context-id #f))
                          (assq-ref annotation 'context-id)))
                     (context-id
                      ;; Look up a context-name label from the options if one is set,
                      ;; otherwise use the retrieved context-name.
                      (getChildOptionWithFallback '(scholarly annotate context-names)
                        (string->symbol _context-id)
                        _context-id))
                     (score-id
                      ;; Recursively determine the name of the 'Score context.
                      ;; If that is \new (no explicit name) set to #f instead
                      (letrec
                       ((score-ctx
                         (lambda (ctx)
                           (let ((parent (ly:context-parent ctx)))
                             (if parent
                                 (if (eq? (ly:context-name parent) 'Score)
                                     (ly:context-id parent)
                                     (score-ctx parent))
                                 "")))))
                       (let ((id (score-ctx context)))
                         (if (string=? id "\\new") #f id))))
                     (grob-type (grob::name grob))
                     )
                    ;; 'context-id is already present so we overwrite it
                    (assq-set! annotation 'context-id context-id)
                    ;; Add the new properties to the annotation
                    (append! annotation
                      `((grob-type . ,grob-type)
                        (score-id . ,score-id)))
                    ;; record annotated grob
                    (set! annotated-grobs (cons grob annotated-grobs))
                    ;; reset list to prevent multiple processing.
                    ;
                    ; TODO: I don't understand why I can kill *all* the list
                    ; after having processed *one* grob.
                    ; What happens to any other annotated grobs (at the same time)?
                    ; I know it is possible to annotate multiple post-events, for example.
                    (set! all-grobs '())))))))
       all-grobs))

     ;; Iterate over collected grobs and produce a list of annotations
     ;; (when annotations are neither printed nor logged the list is empty).
     ((finalize trans)
      (setOption '(scholarly annotations)
        (map
         (lambda (g)
           (let*
            ((annotation (ly:grob-property g 'input-annotation))
             ;; Retrieve location info, which seems to be possible only now
             (grob-location
              (grob-location-properties g
                `((meter . ,(ly:context-property context 'timeSignatureFraction))))))
            (append annotation `((grob-location . ,grob-location)))))
         (reverse annotated-grobs)))))))


% When the score is finalized this engraver
% processes the list of annotations and produces
% appropriate output.
annotationProcessor =
#(lambda (context)
   (make-engraver
    ((finalize trans)
     ;; Sort annotations by the given criteria
     (for-each
      (lambda (s)
        (setOption '(scholarly annotations)
          (sort-annotations (getOption '(scholarly annotations))
            (assq-ref annotation-comparison-predicates s))))
      (reverse (getOption '(scholarly annotate sort-criteria))))

     ;; Optionally print annotations
     (if (getOption '(scholarly annotate print))
         (do-print-annotations))
     ;; Export iterating over all entries in the
     ;; annotation-export-targets configuration list
     (for-each
      (lambda (t)
        (let
         ((er (assq-ref (getOption '(scholarly annotate internal export-routines)) t)))
         ;; skip invalid entries
         (if er
             (er)
             (ly:warning (format "Invalid annotation export target: ~a" t)))))
      (getOption '(scholarly annotate export-targets))))))
